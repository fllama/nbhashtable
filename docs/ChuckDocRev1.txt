Insert:
In order to insert into the table, the hash value must first be obtained. Starting from the bucket corresponding to the hash value, continue quadratic probing until they find a bucket that contains an EMPTY value. If the number of probes to get to that slot was greater than the upper bound stored for the inserted item's hash value, the upper bound should be updated to the number of probe jumps used to reach the EMPTY slot. Otherwise, the probe bound should remain unchanged. If at any point the number of probe jumps exceeds the size of the hash table, the function should return false to signal that the collision was unresolved and the insert operation failed.

Contains:
In order to check for an element in the table, the hash value must first be obtained. Then starting from the bucket corresponding to the hash value, probing should continue until the upper bound of the hash value is exceeded or until the element to be searched for is found. If the element is found return true. Otherwise, if the bounds are exceeded, return false.

Remove:
In order to remove an element from the table, the hash value for the element must first be obtained. Starting from the bucket corresponding to the hash value, continue probing until the element is found or the upper bounds are exceeded. If the upper bound is exceeded return false to signal that the item was unable to be removed. If the item is found set the bucket its located in to EMPTY. If the number of probe jumps it takes to get to the bucket is equal to the upper bounds of the hash value, decrement the upper bound until probing by the number contained within the upper bound results in a non-empty bucket, or the upper bound equals zero.



Insert v2:
When the insert operation is performed on the hash table, the hash table is tasked with trying to place the element in the bucket to which the element's hash value corresponded. In the event that the desired bucket slot is already occupied, the hash table will use a quadratic collision resolution algorithm to find a new bucket for the element to occupy. The number of collisions the element incurs is recorded and the maximum number of collisions that elements of a particular hash value have incurred are saved as an upper bound to minimize unneccessary probing during the "contains" and "remove" operations. If a collision is unable to be resolved, the caller of the function is notified that the "insert" operation failed by a boolean return value.

Contains v2:
When the contains operation is performed on the hash table, the hash table is tasked with locating the specified element within the hash table. The hash table begins by checking the bucket corresponding to the hash value of the element to be located. The hash table will use the upper bound to determine the maximum number of collisions that could have happened for the given element. This allows the hash table's search to be a predetermined depth and not take longer as the size of the hash table grows. After the search has been completed, the caller of the function is notified whether or not the hash table contains the specified element by a boolean return value.

Remove v2:
When the remove operation is performed on the hash table, the hash table is tasked with finding an element and deleting it from the hash table. The hash table first follows the same procedure for locating an element as described in the "contains" operation. Once the element is found, the buckets contents are set to empty. In the event that the element was located the same number of collisions from the hash value as the hash value's upperbounds, the hash table recalculates the hash value's upper bound and updates the upper bound with the new value. In a concurrent implementation an atomic "compare and swap" operation is used to make sure there haven't been any collisions or deletions of elements with the given hash value. In the event that a deletion or collision occurred, the hash table recalculates the upperbound and attempts the "compare and swap" operation again. By using and updating the upper bound, the hash table avoids the costly operation of having to find and reinsert elements that collided with the removed element. The reinsertions would also create more points of contention which would cause creating a concurrent hash table all the more difficult.
